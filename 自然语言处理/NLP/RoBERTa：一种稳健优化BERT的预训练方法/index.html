<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="sherwin"><meta name="keywords" content=""><meta name="description" content="摘要语言模型的预训练带来了显著的性能提高，但比较不同的方法具有一定的挑战性。因为其训练的计算成本很高，同时不同的模型通常又是在不同规模的私有数据集上进行的，而且超参数选择也会对最终结果有重大影响。我们提出了BERT预训练的研究(Devlin等人，2019年)，测量了许多关键超参数和训练数据大小的影响。在实验中，发现了BERT模型的一些问题，同时提出一种新的模型，这种模型可以匹配或超过BERT后发"><meta property="og:type" content="article"><meta property="og:title" content="RoBERTa：一种稳健优化BERT的预训练方法"><meta property="og:url" content="http://sherwinzhang.com/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/NLP/RoBERTa%EF%BC%9A%E4%B8%80%E7%A7%8D%E7%A8%B3%E5%81%A5%E4%BC%98%E5%8C%96BERT%E7%9A%84%E9%A2%84%E8%AE%AD%E7%BB%83%E6%96%B9%E6%B3%95/index.html"><meta property="og:site_name" content="sherwinNG&#39;s blog"><meta property="og:description" content="摘要语言模型的预训练带来了显著的性能提高，但比较不同的方法具有一定的挑战性。因为其训练的计算成本很高，同时不同的模型通常又是在不同规模的私有数据集上进行的，而且超参数选择也会对最终结果有重大影响。我们提出了BERT预训练的研究(Devlin等人，2019年)，测量了许多关键超参数和训练数据大小的影响。在实验中，发现了BERT模型的一些问题，同时提出一种新的模型，这种模型可以匹配或超过BERT后发"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h57grjt545j20et05jglv.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h57hah9hkmj20kp0a775k.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h57htsikvfj20ea04awep.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h57ipozdhtj20nz0bcmyo.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h57j9xejj0j20s60a2768.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h57jprld9mj20ef09jmxz.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h57jivuimbj20ef05ujrp.jpg"><meta property="article:published_time" content="2022-08-15T03:20:21.000Z"><meta property="article:modified_time" content="2022-08-28T14:21:41.212Z"><meta property="article:author" content="sherwin"><meta property="article:tag" content="NLP"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h57grjt545j20et05jglv.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>RoBERTa：一种稳健优化BERT的预训练方法 - sherwinNG&#39;s blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"sherwinzhang.com",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"--",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="sherwinNG's blog" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:40vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>【文言】</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> 文档</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://hexo.fluid-dev.com/" target="_blank" rel="noopener">主题博客 </a><a class="dropdown-item" href="https://hexo.fluid-dev.com/docs/guide/" target="_blank" rel="noopener">配置指南 </a><a class="dropdown-item" href="https://hexo.fluid-dev.com/docs/icon/" target="_blank" rel="noopener">图标用法</a></div></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="RoBERTa：一种稳健优化BERT的预训练方法"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-15 11:20" pubdate>2022年8月15日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 12k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 62 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">RoBERTa：一种稳健优化BERT的预训练方法</h1><div class="markdown-body"><h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>语言模型的预训练带来了显著的性能提高，但比较不同的方法具有一定的挑战性。因为其训练的计算成本很高，同时不同的模型通常又是在不同规模的私有数据集上进行的，而且超参数选择也会对最终结果有重大影响。我们提出了BERT预训练的研究(Devlin等人，2019年)，测量了许多关键超参数和训练数据大小的影响。在实验中，发现了BERT模型的一些问题，同时提出一种新的模型，这种模型可以匹配或超过BERT后发布的每一个模型的性能。我们最好的模型在GLUE, RACE和SQuAD上取得了最先进的结果。这些结果突出了以前忽略的设计选择的重要性。基于此，我们发布了其模型和代码。</p><h2 id="1-文章介绍"><a class="markdownIt-Anchor" href="#1-文章介绍"></a> 1 文章介绍</h2><p>自训练方法，如 ELMo (Peters et al., 2018)、GPT (Radford et al., 2018)、BERT (Devlin et al., 2019)、XLM (Lample and Conneau, 2019) 和 XLNet (Yang et al., 2019) al., 2019) 带来了显着的性能提升，但要确定这些方法的哪些方面贡献最大可能具有挑战性。 因为训练的计算成本很高，限制了我们对模型的微调，还有不同模型通常使用未公开的私人训练数据完成，进一步限制了我们衡量模型的效果。</p><p>我们提出了 BERT 预训练的进一步研究（Devlin 等人，2019 年），其中包括评估超参数调整和训练集大小的影响。 我们发现 了BERT 训练中的不足，并提出了一种改进的 BERT 模型训练方法，我们称之为 RoBERTa，它可以匹配或超过所有后 BERT 方法的性能。 我们的修改很简单，<strong>它们包括：（1）训练模型的时间更长，批量更大，数据更多； (2) 去除下一句预测目标； (3) 较长序列的训练； (4) 动态改变应用于训练数据的遮掩模式。 我们还收集了一个与其他私人使用的数据集相当大小的大型新数据集（CC-NEWS），以更好地控制训练集大小的影响。</strong></p><p>在控制训练数据时，我们改进的训练方法突破了 GLUE 和 SQuAD 上已发布的 BERT 结果。 当对额外数据进行更长时间的训练时，我们的模型在公共 GLUE数据集排行榜上的得分为 88.5，与 Yang 等人报告的 88.4 相匹配（2019）。 我们的模型在 4/9 的 GLUE 任务：MNLI、QNLI、RTE 和 STS-B 上的评分达到了新高度。 我们在 SQuAD 和 RACE 上也获得了最高的得分。 总体而言，我们重新确定 BERT 的掩码语言模型与其他最近提出的训练方法（例如扰动自回归语言建模（Yang 等人，2019））具有相同的竞争力（Yang 等人，2019）。</p><p>综上所述，<strong>本文的贡献在于（1）我们提出了一组重要的 BERT 设计选择和训练策略，并引入了能够提高下游任务性能的替代方案； (2) 我们使用新的数据集 CC-NEWS，并确认使用更多数据进行预训练可以进一步提高下游任务的性能； (3) 我们的训练改进表明，在正确的设计选择下，掩码类语言模型预训练与所有其他最近发布的方法相比依旧具有很强竞争力。</strong> 我们利用PyTorch 实现了该模型、以及预训练和微调代码。</p><h2 id="2-背景"><a class="markdownIt-Anchor" href="#2-背景"></a> 2 背景</h2><p>在本节中，我们简要概述了 BERT (Devlin et al., 2019) 预训练方法以及我们将在下一节中通过实验检查的一些调优方法。</p><h3 id="21-初始设置"><a class="markdownIt-Anchor" href="#21-初始设置"></a> 2.1 初始设置</h3><p>BERT 将两部分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">x_1,... ,x_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.10903em">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>y</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">y_1,..., y_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.03588em">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.03588em">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.10903em">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的串联作为输入。 这两个片段作为单个输入序列呈现给 BERT，并用特殊标记分隔它们：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>C</mi><mi>L</mi><mi>S</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub><mo separator="true">,</mo><mo stretchy="false">[</mo><mi>S</mi><mi>E</mi><mi>P</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>y</mi><mi>M</mi></msub><mo separator="true">,</mo><mo stretchy="false">[</mo><mi>E</mi><mi>O</mi><mi>S</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[CLS],x_1,...,x_N,[SEP],y_1,...,y_M,[EOS]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:.07153em">C</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.10903em">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.03588em">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.03588em">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.10903em">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mclose">]</span></span></span></span>。 对M 和 N 约束是 M + N &lt; T ，其中 T 是控制训练期间最大序列长度的参数。<br>该模型首先在大型未标记文本语料库上进行预训练，然后使用最终任务标记数据进行微调。</p><h3 id="22-结构说明"><a class="markdownIt-Anchor" href="#22-结构说明"></a> 2.2 结构说明</h3><p>BERT 使用了 Transformer 架构（Vaswani 等人，2017 年），我们不会对其进行详细回顾。 我们使用具有 L 层的Transformer结构。 每个块使用的自注意头为A个，隐藏维度为 H。</p><h3 id="23-训练目标"><a class="markdownIt-Anchor" href="#23-训练目标"></a> 2.3 训练目标</h3><p>BERT的预训练模型会考虑两个任务：带掩码的语言模型和下一句预测任务。</p><p>带掩码的语言模型 (Masked Language Model, MLM) 在输入序列中随机样本替换为特殊标记 [MASK]。 MLM是预测掩码标记的交叉熵损失。 BERT 首先统一选择 15% 的输入标记。 在选定的标记中，80% 被 [MASK] 替换，10% 保持不变，10% 被随机选择的词汇标记替换。<br>在最初的实现中，随机掩码和替换在开始时执行一次，然后在训练期间保存。同时在整个训练过程中，虽然数据是一样的，但是每个训练句子的掩码并不会保持一致（参见第 4.1 节）。</p><p>下一句预测（Next Sentence Prediction NSP）是一种二元分类损失，用于预测原始文本中两段是否相连。通过从文本语料库中提取连续句子来创建正样本。负样本是通过将不同文档中的片段配对来创建的。以相等的概率采样正、负样本。</p><p>NSP目标旨在提高下游任务的性能，如自然语言推理（Bowman等人，2015），该任务需要对句子之间的关系进行推理。</p><h3 id="24-优化方法"><a class="markdownIt-Anchor" href="#24-优化方法"></a> 2.4 优化方法</h3><p>通过Adam（Kingma和Ba，2015）使用以下参数对BERT进行优化：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>β</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">β_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.05278em">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05278em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>=0.9，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>β</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">β_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.05278em">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05278em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>=0.999，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi><mo>=</mo><mn>1</mn><mi>e</mi><mo>−</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">\epsilon=1e-6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span></span></span></span>，L2的衰减权重为0.01。在前10000个步骤中，学习速率被设定到1e-4的峰值，然后线性衰减。BERT训练时，所有层和注意力权重上的 dropout 均为0.1，并增加了GELU激活函数（Hendrycks和Gimpel，2016）。模型预训练更新参数：S=1000000，小批量设定参数：B=256，最大长度token：T=512。</p><h3 id="25-数据介绍"><a class="markdownIt-Anchor" href="#25-数据介绍"></a> 2.5 数据介绍</h3><p>BERT使用了BOOKCORPUS（Zhu等人，2015）和英语维基百科的组合共16GB的未压缩文本进行训练。</p><h2 id="3-实验设置"><a class="markdownIt-Anchor" href="#3-实验设置"></a> 3 实验设置</h2><p>在本节中，我们描述了BERT复现研究的实验设置。</p><h3 id="31-初始启动"><a class="markdownIt-Anchor" href="#31-初始启动"></a> 3.1 初始启动</h3><p>我们在FAIRSEQ（Ott等人，2019年）中重新实现了BERT。我们主要使用了第2节中给出的原始BERT优化超参数，但峰值学习率和步骤数除外，这两个参数会针对每个设置进行调整。此外，我们还发现训练对Adam非常敏感，在某些情况下，我们在微调后获得了更好的性能。同样，我们发现设置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>β</mi><mn>2</mn></msub><mo>=</mo><mn>0.98</mn></mrow><annotation encoding="application/x-tex">β_2=0.98</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.05278em">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05278em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">9</span><span class="mord">8</span></span></span></span>可以提高大批量训练时的稳定性。<br>我们使用token最大值为T=512进行预训练。与Devlin等人（2019年）不同，我们不会随机增加短序列，也不会在前90%的更新中使用缩短的序列长度进行训练，而是使用全长序列进行训练。<br>我们在DGX-1机器上使用混合精度浮点算法进行训练，每台机器配备为：8×32GB Nvidia V100 GPU。</p><h3 id="32-数据介绍"><a class="markdownIt-Anchor" href="#32-数据介绍"></a> 3.2 数据介绍</h3><p>bert类模型的预训练非常依赖于大量的文本。Baevski等人(2019)指出，增加数据量可以改善最终任务的性能。之前一些研究已经在比原始BERT更大、更多样化的数据集上进行了训练(Radford等人，2019年;Yang等人，2019;Zellers等人，2019年)。不幸的是，并不是所有额外的数据集都被公开。对于我们的研究，我们专注于收集尽可能多的数据进行实验，使我们能够匹配数据的总体质量和数量，进而适应每次的结果比较。</p><p>我们考虑了五个不同领域的英语语料库，总共超过160GB的未压缩文本。主要使用了以下文本语料库:</p><ul><li><p>BOOKCORPUS (Zhu et al.， 2015)加上英文维基百科。这是用来训练BERT的原始数据。(16GB)。</p></li><li><p>CC-NEWS，从CommonCrawl新闻数据集的英语部分收集(Nagel, 2016)到的数据。该数据包含2016年9月至2019年2月期间的6300万篇英语新闻文章。(过滤后包含76GB)</p></li><li><p>OPENWEBTEXT (Gokaslan和Cohen, 2019)， Radford等人(2019)描述的WebText语料库的开源数据。这部分数据是从Reddit上分享的url中提取的web内容。(38GB)</p></li><li><p>STORIES，一个在Trinh和Le(2018)中引入的数据集，包含CommonCrawl数据的子集，用来匹配Winograd模式的故事风格。(31 GB)。</p></li></ul><h3 id="33-评估方法"><a class="markdownIt-Anchor" href="#33-评估方法"></a> 3.3 评估方法</h3><p>在之前的研究中，我们使用以下三个基准来评估我们在下游任务中预训练的模型。</p><p><strong>通用语言理解评估(The General Language Understanding Evaluation GLUE)方法</strong>(Wang et al.， 2019b)由9个数据集组成，用于评估自然语言理解系统。任务分为单句分类任务和句子对分类任务。GLUE官方会提供分割好的数据，以及一个提交服务器和允许参与者根据私人测试数据评估和比较他们系统的排行榜。</p><p>在第4节的研究中，我们介绍了在相应的单任务训练数据上微调预训练模型后的结果。我们的微调过程和最初的BERT论文保持一致(Devlin et al.， 2019)。</p><p>在第5节中，我们另外介绍了从公共排行榜中获得的测试集结果。这些结果依赖于一些特定任务的修改。</p><p>SQuAD斯坦福问答数据集(The Stanford Question Answering Dataset SQuAD)提供了一段上下文和一个问题。其任务是从上下文中提取相关答案来回答这个问题。我们评估了《SQuAD》的两个版本:V1.1和V2.0 (Rajpurkar et al.， 2016年和2018年)。在V1.1中，上下文中总是包含一个答案，而在V2.0中，有些问题在提供的上下文中没有得到回答，这使得任务更具挑战性。<br>对于SQuAD V1.1，我们采用与BERT (Devlin et al.， 2019)相同的预测方法。对于SQuAD V2.0，我们添加了一个额外的二元分类器来预测问题是否可回答，我们通过对分类项和损失项求和来联合训练该模型。在评估过程中，我们只预测分类为可回答的范围。</p><p>RACE （The ReAding Comprehension from Examinations ）(Lai et al.， 2017)任务是一个大型阅读理解数据集，包含超过2.8万篇文章和近10万个问题。该数据集来自中国的英语考试，专为初高中学生设计。在RACE中，每一篇文章都有多个问题。每个问题的任务是从四个选项中选择一个正确答案。RACE比其他流行的阅读理解数据集有更长的上下文，并且需要推理的问题的比例更大。</p><h2 id="4-训练过程分析"><a class="markdownIt-Anchor" href="#4-训练过程分析"></a> 4 训练过程分析</h2><p>本节将探索哪些选择对成功预训练BERT模型比较重要。我们保持模型体系结构不变。具体来说，我们在训练BERT模型时使用与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>B</mi><mi>A</mi><mi>S</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{BASE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.05017em">B</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.05764em">S</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>相同的配置(L = 12, H = 768, A = 12, 110M参数)。</p><h3 id="41-动-静态掩码对比"><a class="markdownIt-Anchor" href="#41-动-静态掩码对比"></a> 4.1 动、静态掩码对比</h3><p>正如第2节所讨论的，BERT依赖于随机掩码和预测token。原始的BERT实现在数据预处理过程中只进行一次掩码，产生单一的静态掩码。为了避免在每个epoch中对训练实例使用相同的掩码，训练数据被复制10份，以便每个序列在40个训练epoch中以10种不同的方式进行掩码。所以，每个训练序列在训练过程中使用相同的掩码训练4次。<br>我们将此策略与动态掩码进行比较。**在动态掩码中，每次向模型提供序列时都会生成掩码。**当需要更多的步骤或更大的数据集进行预训练时，这一点的影响将非常大。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h57grjt545j20et05jglv.jpg" srcset="/img/loading.gif" lazyload alt="image-20220815150326591"></p><blockquote><p>表1: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>B</mi><mi>A</mi><mi>S</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{BASE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.05017em">B</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.05764em">S</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>静态屏蔽和动态屏蔽的比较。我们统计了SQuAD的F1值，以及MNLI-m和SST-2的准确性。结果是5个随机初始化(种子)的中值。参考结果来自Yang等人(2019)。</p></blockquote><p>表1比较了Devlin等人(2019)发布的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>B</mi><mi>A</mi><mi>S</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{BASE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.05017em">B</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.05764em">S</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>结果与我们重新实现静态或动态掩码的结果。我们发现，采用静态掩码的重新实现与原始BERT模型的性能相似，而动态掩码略好于静态掩码。<br>考虑到这些结果和动态掩码的额外效益，我们在接下来的实验中使用动态掩码。</p><h3 id="42-模型输入规范化和下一句预测"><a class="markdownIt-Anchor" href="#42-模型输入规范化和下一句预测"></a> 4.2 模型输入规范化和下一句预测</h3><p>在原始BERT预训练过程中，模型会观察两个连接的句子内容，它们要么从同一文档(p = 0.5)连续采样，要么从不同的文档采样。除了构建带掩码的语言模型(MLM)外，该模型还通过衡量下一句预测(NSP)损失来预测观察到的文档片段是否来自相同的文档。<br>假设下一句预测的损失是训练原始BERT模型的一个重要因素。Devlin等人(2019)观察到，去除NSP会损害性能，将会使QNLI、MNLI和SQuAD 1.1的性能显著下降。然而，最近的一些研究对NSP损失的必要性提出了质疑(Lample和Conneau, 2019;Yang等人，2019;Joshi等人，2019年)。<br>为了更好地理解这种差异，我们比较了几种不同的训练形式:</p><ul><li>SEGMENT-PAIR+NSP: 这遵循BERT (Devlin等人，2019)中使用的原始输入格式，带有NSP损失。每个输入都有一对片段，每个片段可以包含多个自然句子，但组合的总长度必须小于512个token。此处我们保留了NSP的损失。</li><li>SENTENCE-PAIR+NSP: 每个输入包含一对自然句子，或者从一个文档的连续部分采样，或者从单独的文档采样。由于这些输入明显少于512个token，因此我们增加了批处理大小，使token的总数保持类似于SEGMENT-PAIR+NSP。此处我们保留了NSP的损失。</li><li>FULL-SENTENCES: 每个输入都包含从一个或多个文档连续采样的完整句子，因此总长度最多为512个token。输入可以跨越文档边界。当到达一个文档末尾时，我们开始对下一个文档中的句子进行采样，并在文档之间添加额外的分隔符。此处我们移除了NSP损失评估。</li><li>DOC-SENTENCES: 输入的构造类似于完整句子，只是它们不能跨越文档边界。在文档末尾采样的输入可能小于512个token，因此我们在这些情况下动态地增加批处理大小，以达到与FULL- sentence相似的标记总数。我们移除了NSP损失评估。</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h57hah9hkmj20kp0a775k.jpg" srcset="/img/loading.gif" lazyload alt="image-20220815152046808"></p><blockquote><p>表2: 在BOOKCORPUS和WIKIPEDIA上预训练的基本模型结果。所有模型训练1M 步，批大小256。我们计算了SQuAD的F1值，MNLI-m、SST-2和RACE的准确性。结果是五个随机初始化(种子)的中值。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>B</mi><mi>A</mi><mi>S</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{BASE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.05017em">B</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.05764em">S</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mi>L</mi><mi>N</mi><mi>e</mi><msub><mi>t</mi><mrow><mi>B</mi><mi>A</mi><mi>S</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">XLNet_{BASE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.07847em">X</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.05017em">B</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.05764em">S</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>的结果来自Yang等人(2019)。</p></blockquote><p>表2显示了四种不同设置的实验结果。我们首先比较了Devlin等人(2019)的原始SEGMENT-PAIR输入格式和SENTENCE-PAIR格式；两种格式都保留了NSP损失，但后者使用单个句子。我们发现，使用单独的句子会损害后续任务的表现，我们认为这是因为模型无法学习长期依赖。</p><p>接下来，我们比较没有NSP损失的训练和使用单个文档中的文本块(DOC-SENTENCES)的训练。我们发现，与Devlin等人(2019)相比，该设置优于最初公布的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>B</mi><mi>A</mi><mi>S</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{BASE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.05017em">B</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.05764em">S</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>结果，删除NSP损失略微改善了下游任务的性能。原始的BERT实现可能只删除了损失项，而仍然保留SEGMENT-PAIR输入格式。</p><p>最后，我们发现限制来自单个文档的序列(DOC-SENTENCES)比来自多个文档的序列(FULL-SENTENCES)性能略好。然而，由于DOC-SENTENCES格式导致的批处理大小不同，我们在其余实验中仍然使用FULL-SENTENCES，以便与相关工作进行更容易的比较。</p><h3 id="43-大批量训练"><a class="markdownIt-Anchor" href="#43-大批量训练"></a> 4.3 大批量训练</h3><p>之前的神经机器翻译工作表明，当学习率适当提高时，使用非常大的小批量训练可以提高优化速度和结束任务的性能(Ott et al.， 2018)。最近的研究也表明了BERT同样适用于大规模批量训练(You等人，2019年)。</p><p>Devlin等人(2019)最初对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>B</mi><mi>A</mi><mi>S</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{BASE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.05017em">B</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.05764em">S</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>进行了1M 步、批大小为256的训练。通过梯度积累，这在计算成本上等价于批量大小为2K、125K步或批量大小为8K、31K步的训练。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h57htsikvfj20ea04awep.jpg" srcset="/img/loading.gif" lazyload alt="image-20220815154204236"></p><blockquote><p>表3: 在不同批处理大小(bsz)的BOOKCORPUS和WIKIPEDIA上训练的基本模型上对训练数据(ppl)的困惑度和准确性。我们调整了每个设置的学习率(lr)；模型传递数据的次数(epoch)是相同的，同时计算资源也是相同的。</p></blockquote><p>在表3中，我们比较了随着批处理规模的增加，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>B</mi><mi>A</mi><mi>S</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{BASE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.05017em">B</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.05764em">S</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>的复杂度和结束任务性能，并控制了通过训练数据的次数。我们观察到，大批量训练提高了掩码语言建模目标的困惑度和结束任务的准确性。通过分布式数据并行训练，大批量的数据也更容易并行化，在后面的实验中，我们使用批量大小值为8K进行训练。<br>值得注意的是，You等人(2019)使用更大的批大小训练BERT模型，最多达到32K的批量。该部分工作我们在本文中不做讨论，留给后来的学者进一步研究。</p><h3 id="44-文本编码"><a class="markdownIt-Anchor" href="#44-文本编码"></a> 4.4 文本编码</h3><p>字节对编码(Byte-Pair Encoding BPE) (Sennrich等人，2016)是字符级和单词级表示的混合，它可以处理自然语言语料库中常见的大型词汇。BPE依赖于子词单元，通过对训练语料库进行统计分析来提取子词单元，而不是全部词汇。<br>BPE词汇量通常在10K-100K子词单位之间。然而，在建模大型和多样化的语料库(如本工作中考虑的语料库)时，unicode字符可以占这个词汇表的相当大的一部分。Radford等人(2019)引入了一种巧妙的BPE实现，它使用字节而不是 unicode 字符作为基本子字单元。使用字节可以学习中等大小(50K单位)的子单词词汇表，它仍然可以在不引入任何未知标记的情况下对任何输入文本进行编码。</p><p>原始BERT实现(Devlin等人，2019年)使用了一个大小为30K的字符级BPE词汇表，该词汇表是在使用启发式标记规则下对输入进行预处理后学习的。在Radford等人(2019)之后，我们考虑使用包含50K子词单元的更大字节的BPE词汇表来训练BERT，而不需要对输入进行任何额外的预处理或标记。这分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>B</mi><mi>A</mi><mi>S</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{BASE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.05017em">B</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.05764em">S</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>增加了大约15M和20M的额外参数。<br>早期的实验显示，这些编码之间只有轻微的差异，Radford等人(2019)的BPE在某些结束任务表现略差。尽管如此，我们相信通用编码方案的优势大于性能上的轻微下降，并在我们的其余实验中使用这种编码。这些编码更详细的比较留给以后的工作。</p><h2 id="5-roberta"><a class="markdownIt-Anchor" href="#5-roberta"></a> 5 RoBERTa</h2><p>在前一节中，我们讨论了对BERT预训练过程进行修改，以提高结束任务的性能。现在，我们将汇总这些改进并评估它们的综合影响。我们将这种配置称为RoBERTa，用于健壮优化BERT方法。具体来说，RoBERTa使用动态屏蔽(章节4.1)、没有NSP损失的完整句子(章节4.2)、大的小批量(章节4.3)和更大的字节级BPE(章节4.4)进行训练。</p><p>此外，我们研究了其他两个在之前的工作中被忽视的重要因素:<br>(1) 用于预训练的数据<br>(2) 训练通过数据的次数<br>例如，最近提出的XLNet架构(Yang等人，2019年)是使用比原始BERT多近10倍的数据进行预训练的(Devlin等人，2019年)。它的批大小是BERT的8倍，优化步骤是BERT的一半。</p><p>为了帮助从其他建模选择中分离出这些因素的重要性(例如，训练前目标)，我们开始按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>架构(L = 24, H = 1024, A = 16,355M参数)训练RoBERTa。我们在Devlin等人(2019)使用的可比较的BOOK-CORPUS + WIKIPEDIA数据集上预训练100K步，使用1024 V100 GPU对模型进行了大约一天的预训练。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h57ipozdhtj20nz0bcmyo.jpg" srcset="/img/loading.gif" lazyload alt="image-20220815161158982"></p><blockquote><p>表4:当我们预训练更多的数据(16GB→160GB的文本)和更长的预训练(100K→300K→500K步骤)时，RoBERTa的结果展示。RoBERTa与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>的架构和训练目标相匹配。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mi>L</mi><mi>N</mi><mi>e</mi><msub><mi>t</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">XLNet_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.07847em">X</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>的结果分别来自Devlin等人(2019)和Yang等人(2019)。所有GLUE任务的完成结果可以在附录中找到。</p></blockquote><p>在表4中展示了训练的结果。当控制训练数据时，我们观察到RoBERTa比最初报告的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>结果有很大的改进，这再一步证明了我们在第4节中探讨的设计选择的重要性。</p><p>接下来，我们将这些数据与3.2节中描述的另外三个数据集结合起来。我们使用与之前相同数量的训练步骤(100K)在组合数据上训练RoBERTa。我们总共预训练了超过160GB的文本。我们观察到所有下游任务的性能进一步提高，验证了数据大小和预训练多样性的重要性。</p><p>最后，我们对RoBERTa进行了更长的预训练，将预训练步数从100K增加到300K，再进一步增加到500K。我们再次观察到下游任务性能的显著提高，300K和500K步模式在大多数任务中优于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mi>L</mi><mi>N</mi><mi>e</mi><msub><mi>t</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">XLNet_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.07847em">X</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。我们注意到，即使我们训练时间最长的模型也不会过度拟合我们的数据，会从额外的训练中受益。</p><p>在本文的剩余部分，我们在三个不同的基准上评估我们最好的RoBERTa模型:GLUE, SQuaD和RACE。</p><h3 id="51-在glue上的结果"><a class="markdownIt-Anchor" href="#51-在glue上的结果"></a> 5.1 在GLUE上的结果</h3><p>对于GLUE，我们考虑两种微调设置。在第一个设置（single-task, dev）中，我们对GLUE任务微调了RoBERTa，只使用对应任务的训练数据。对于每个任务，我们考虑一个有限的超参数集，其批大小∈{16,32}，学习率∈{1e−5,2e−5,3e−5}，在前6%的步骤中进行线性递增，然后线性衰减到0。我们调整了10个epoch，并基于开发集上的每个任务评估指标执行early stopping。其余超参数与训练前保持一致。在这个设置中，我们观察了在五个随机初始化中每个任务的中值结果，并没有模型集成。</p><p>在第二个设置(ensembles, test)中，我们通过GLUE排行榜将RoBERTa与测试集上的其他方法进行比较。GLUE排行榜的许多提交都依赖于多任务微调，而我们的提交只依赖于单任务微调。对于RTE、STS和MRPC，我们发现从MNLI单任务模型开始进行微调是有帮助的，而不是从基线预训练RoBERTa开始。我们探索了一个稍微宽一些的超参数空间，具体内容见附录。</p><p>GLUE的两个任务需要特定任务的微调方法，以获得具有竞争力的排行榜结果。</p><p>QNLI: GLUE排行榜上最近提交的结果采用了QNLI任务的两两排序公式(Liu et al.， 2019b,a;Yang等人，2019)。这种公式大大简化了评估任务，但不能直接与BERT相比(Devlin et al.， 2019)。根据最近的工作，我们的测试提交采用了排序方法，但是为了与BERT直接比较，我们也产出了基于纯分类方法的结果。</p><p>WNLI: 我们发现提供的NLI-format的WNLI数据处理起来很有挑战性。所以我们使用来自Super- GLUE (Wang et al.， 2019a)重新格式化的WNLI数据，它用于表示查询代词和指示物的跨度。我们使用Kocijan等人(2019)的利润率排名损失对RoBERTa进行微调。对于给定的输入句子，我们使用space (Honnibal and Montani, 2017)从句子中提取额外的候选名词短语，并对我们的模型进行微调。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h57j9xejj0j20s60a2768.jpg" srcset="/img/loading.gif" lazyload alt="image-20220815163209750"></p><blockquote><p>表5:GLUE的结果。所有结果都基于24层架构。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mi>L</mi><mi>N</mi><mi>e</mi><msub><mi>t</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">XLNet_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.07847em">X</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>的结果分别来自Devlin等人(2019)和Yang等人(2019)。开发集上的RoBERTa结果是五次运行的中位数。测试集上的RoBERTa结果是单任务模型的集合。对于RTE、STS和MRPC，我们从MNLI模型而不是基线预训练模型开始进行微调。平均数据来自GLUE排行榜。</p></blockquote><p>在表5中展示了我们的结果。在第一种设置(single-task, dev)中，RoBERTa在所有9个GLUE任务开发集上都取得了最先进的结果。同时，RoBERTa使用与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>相同的掩码语言建模预训练目标和架构，但始终优于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mi>L</mi><mi>N</mi><mi>e</mi><msub><mi>t</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">XLNet_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.07847em">X</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。<br>在第二种设置中(ensembles, test)，我们将RoBERTa提交给GLUE排行榜，并在9个任务中的4个取得了最先进的结果，并获得了迄今为止最高的平均分。这是特别令人兴奋的，因为RoBERTa不依赖于多任务微调，不像大多数其他结果的提交。我们期望未来的工作可以通过加入更复杂的多任务微调程序来进一步改进这些结果。</p><h3 id="52-在-squad上的结果"><a class="markdownIt-Anchor" href="#52-在-squad上的结果"></a> 5.2 在 SQuAD上的结果</h3><p>在SQuAD上，我们采用了比以往更简单的方法。尽管BERT (Devlin等人，2019年)和XLNet (Yang等人，2019年)都使用额外的QA数据集来扩充他们的训练数据，但我们只使用提供的SQuAD训练数据对RoBERTa进行微调。Yang等人(2019)也采用了自定义的分层学习率微调XLNet，而我们对所有层使用相同的学习率。<br>对于SQuAD 1.1，我们遵循与Devlin等人(2019)相同的微调程序。对于SQuAD v2.0，我们对给定的问题是否可回答进行了分类;我们通过对分类项和跨度损失项求和的方法，将该分类器与跨度预测器联合训练。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h57jprld9mj20ef09jmxz.jpg" srcset="/img/loading.gif" lazyload alt="image-20220815164723912"></p><blockquote><p>表6:SQuAD的结果。†表明结果依赖于额外的外部训练数据。RoBERTa在开发和测试设置中只使用提供的SQuAD数据。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mi>L</mi><mi>N</mi><mi>e</mi><msub><mi>t</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">XLNet_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.07847em">X</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>的结果分别来自Devlin等人(2019)和Yang等人(2019)。</p></blockquote><p>表6展示了我们的结果。在SQuAD v1.1中，RoBERTa与XLNet最先进的开发集相匹配。在SQuAD 2.0版本的开发套件中，RoBERTa设置了全新方法，比XLNet提高了0.4分(EM)和0.6分(F1)。<br>我们还将RoBERTa提交到公开的SQuAD 2.0排行榜，并评估它与其他系统的性能。大多数顶级系统都建立在BERT (Devlin等人，2019年)或XLNet (Yang等人，2019年)的基础上，这些系统都依赖于额外的外部训练数据。相比之下，我们的提交没有使用任何额外的数据。<br>除了一个模型，RoBERTa模型比其他提交的模型都要好。同时，RoBERTa是那些不依赖于数据增强的系统中得分最高的系统。</p><h3 id="53-在race上的结果"><a class="markdownIt-Anchor" href="#53-在race上的结果"></a> 5.3 在RACE上的结果</h3><p>在RACE中，系统提供了一段文本、一个相关的问题和四个候选答案。系统需要对四个候选答案中哪个是正确的进行分类。<br>为了完成这个任务，我们修改RoBERTa，将每个候选答案与相应的问题和文章连接起来。然后，我们对这四个序列进行编码，并通过一个全连接层传递得到的[CLS]表示，该层用于预测正确答案。我们截断长于128个token的问题-答案对，如果需要还会截断通道，这样总长度最多不超过512个token。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h57jivuimbj20ef05ujrp.jpg" srcset="/img/loading.gif" lazyload alt="image-20220815164046771"></p><blockquote><p>表7:RACE测试集的结果。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>R</mi><msub><mi>T</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">BERT_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord mathdefault" style="margin-right:.05764em">E</span><span class="mord mathdefault" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mi>L</mi><mi>N</mi><mi>e</mi><msub><mi>t</mi><mrow><mi>L</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">XLNet_{LARGE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.07847em">X</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:.05764em">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>的结果来自Yang等人(2019)。</p></blockquote><p>RACE测试集的结果如表7所示。RoBERTa在中等和高级设置中都是最高得分。</p><h2 id="6-相关工作"><a class="markdownIt-Anchor" href="#6-相关工作"></a> 6 相关工作</h2><p>预训练方法设计有不同的训练目标，包括语言建模（Dai 和 Le，2015；Peters 等，2018；Howard 和 Ruder，2018）、机器翻译（McCann 等，2017）和掩码语言建模（Devlin et al., 2019;Lample and Conneau, 2019）。最近的许多论文都对每个最终任务使用了微调模型的基本方法（Howard and Ruder, 2018;Radford et al., 2018），以及使用一些变体的预训练掩码语言模型。然而，较新的方法通过多任务微调（Dong 等人，2019 年）、结合实体嵌入（Sun 等人，2019 年）、跨度预测（Joshi 等人，2019 年）、和自回归预训练的多种变体（Song 等人，2019 年；Chan 等人，2019 年；Yang 等人，2019 年）。通过训练更大的模型和更多的数据，性能通常也会得到提高（Devlin 等人，2019 年；Baevski et al., 2019; Yang et al., 2019;Radford et al., 2019)。我们的目标是复制、简化和更好地调整BERT 的训练，作为更好地了解所有这些方法的相对性能的参考点。</p><h2 id="7-结论"><a class="markdownIt-Anchor" href="#7-结论"></a> 7 结论</h2><p>在预训练BERT模型时，我们评估了许多设计决策。结果发现通过对模型进行更长的训练，在更多的数据上使用更大的批处理，可以大大提高性能，同时去掉了下一句预测目标，使用长序列训练，增加动态改变掩码模式。我们改进的预训练模型，称之为RoBERTa，在GLUE、RACE和SQuAD上实现了非常不错的结果，并且不需要对GLUE进行多任务优化，不需要对SQuAD进行额外的数据训练。这些结果说明了以前被忽视了的设计决策的重要性，并表明BERT的预训练目标与最近提出的替代方案相比仍然具有竞争力。</p><p>此外，我们还使用了一个新的数据集CC-NEWS，并在下地址发布了用于预训练和微调的模型和代码：<a href="https://github.com/pytorch/fairseq" target="_blank" rel="noopener">https://github.com/pytorch/fairseq</a>.</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/" class="category-chain-item">自然语言处理</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/NLP/">#NLP</a></div></div><div class="license-box my-3"><div class="license-title"><div>RoBERTa：一种稳健优化BERT的预训练方法</div><div>http://sherwinzhang.com/自然语言处理/NLP/RoBERTa：一种稳健优化BERT的预训练方法/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>sherwin</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年8月15日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E3%80%8A%E4%BA%BA%E4%B8%96%E9%97%B4%E3%80%8B%E5%B0%8F%E8%AF%B4%E5%B7%B2%E9%98%85/" title="《人世间》小说已阅"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">《人世间》小说已阅</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/NLP/BERT%E4%B9%8B%E5%90%8E%EF%BC%8CNLP%E4%B8%BB%E8%A6%81%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E6%BC%94%E5%8F%98%E6%A2%B3%E7%90%86/" title="BERT之后，NLP主要预训练模型演变梳理"><span class="hidden-mobile">BERT之后，NLP主要预训练模型演变梳理</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="lv-container" data-id="city" data-uid="MTAyMC81NzExNy8zMzU4MQ=="><script type="text/javascript">Fluid.utils.loadComments("#lv-container",function(){Fluid.utils.createScript("https://cdn-city.livere.com/js/embed.dist.js")})</script><noscript>Please enable JavaScript to view the comments</noscript></div></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing;(t=t.getElementById("subtitle"))&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible"))}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>